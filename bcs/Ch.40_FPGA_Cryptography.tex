\chapter{FPGA usages in cryptography\label{FPGA_crypto}}
Due to the high demand on fast cryptographic methods, optimized implementations
became of huge interest. Hence the motivation behind developing faster FPGA
implementation of cryptographic schemes. In this chapter we are giving an
overview of optimized FPGA implementations for R-LWE.

\begin{figure}[H]

    \includegraphics[scale=0.25]{high_level_impl.png}
    \caption{An optimized high level implementation of the three building
    blocks for a public key cryptosystem \citep{FPGA_Post_Quantum_Primitives}}
    \label{fig:high_level_pkc_impl}

\end{figure}

The implementation as seen in Figure \ref{fig:high_level_pkc_impl} consist of
three different modules: key generation, encryption and decryption. These
modules consist of a few basic operations, polynomial multiplication,
polynomial addition, subtraction and scalar division to the nearest integer.
The most expensive complexity-wise is the modulo operation which can take a few
hundred LUTs. Which is why these designs try to minimize the amount of modulo
operations with operations such as conditional assignment
\citep{FPGA_Post_Quantum_Primitives}. The way the noise sampler and the true
random number generator works is out of the scope of this paper.

\begin{itemize}

    \item
        Polynomial addition (Figure \ref{fig:poly_add}) and subtraction (Figure
        \ref{fig:poly_sub}) are the most common operations in the
        R-LWE cryptosystem and thus need to be fast. It uses a hardware circuit
        to do the polynomial addition/subtraction and conditional assignment to
        avoid using the modulo operation.

        \begin{figure}[H]
            \centering
            \begin{subfigure}[b]{0.4\textwidth}
                \centering
                \includegraphics[scale=0.5]{polynomial_addition.png}
                \caption{Polynomial addition
                \citep{FPGA_Post_Quantum_Primitives}}

                \label{fig:poly_add}
            \end{subfigure}
            ~
            \begin{subfigure}[b]{0.4\textwidth}
                \centering
                \includegraphics[scale=0.4]{polynomial_subtraction.png}
                \caption{Polynomial subtraction
                \citep{FPGA_Post_Quantum_Primitives}}
                \label{fig:poly_sub}
            \end{subfigure}
        \end{figure}

    \item
        Scalar multiplication (Figure \ref{fig:scalar_div}) uses multiplexers to once again save LUTs as
        $m$ is an $n$-bit vector, when computing $t\cdot m$ we essentially
        choose $t$ or $0$.

        \begin{figure}[H]
            \centering
            \includegraphics[scale=0.5]{scalar_multiplication.png}
            \caption{Scalar multiplication \citep{FPGA_Post_Quantum_Primitives}}
            \label{fig:scalar_mul}
        \end{figure}

    \item
        Let $d = (c_0 - s \cdot c_1)$ and $t = \frac{t}{2}$, we can implement
        scalar division to the nearest integer by computing
        \[|d - t| < \frac{t}{2} \quad ? \quad 1 \quad : \quad 0\]

        As $|d - t|$ measures the distance between $d$ and $t$; if the
        distance between the two is larger than $t / 2$ it means that $d$ and
        $t$ are far from each other, this means that $\frac{d}{t}$ the nearest
        integer will be $0$. On the other hand if $|d - t|$ is smaller than $t
        / 2$ it means that the nearest integer will be $1$.


        \begin{figure}[H]
            \centering
            \includegraphics[scale=0.5]{scalar_division.png}
            \caption{Scalar division \citep{FPGA_Post_Quantum_Primitives}}
            \label{fig:scalar_div}
        \end{figure}


    \item
        Polynomial multiplication is by far the most complex of these modules.
        Multiplication can change the degree of the polynomial, which increases
        the complexity of the component. It uses \textit{Number Theoretic
        Transform} (NTT) which is a generalized version of FFT over the ring
        $R_q = R / \langle q \rangle = \bZ_q [x] / (x^n + 1)$ to compute the
        polynomials. The NTT equation is the following: let $\omega$ be the
        $n$-th root of unity in the field of the polynomial ring.

        \[ X_i = \sum^{n-1}_{k=0} x_k \cdot \omega^{i\cdot k} \]

        $\omega$ has to satisfy the following conditions, firstly
        $\omega^n = 1 \mod q$. Secondly the period of
        $\omega^i \ \forall i \in \{1, 2, 3, \ldots, n - 1\}$ has to be exactly
        $n$.

        \begin{figure}[H]
            \centering
            \begin{subfigure}[b]{0.4\textwidth}
                \centering
                \includegraphics[scale=0.5]{polynomial_multiplication.png}
                \caption{Polynomial multiplication \citep{FPGA_Post_Quantum_Primitives}}
                \label{fig:poly_mul}
            \end{subfigure}
            ~
            \begin{subfigure}[b]{0.4\textwidth}
                \centering
                \includegraphics[scale=0.25]{number_theoretic_transform.png}
                \caption{Number theoretic transform
                \citep{FPGA_Post_Quantum_Primitives}}
                \label{fig:ntt}
            \end{subfigure}
        \end{figure}

\end{itemize}



