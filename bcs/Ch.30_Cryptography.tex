\chapter{Cryptography\label{crypto}}
In this chapter we will discuss different forms of cryptography and the
mathematics behind it. Cryptography has always been important, it is been used
since ancient times to secure communication. One of the earliest forms of
cryptography was the Caesar cipher, invented by Julius Caesar in ancient Rome.
The Caesar cipher is a \textit{secret-key cipher}. A symmetric cipher is a
cipher where users agree on a key that is used to encrypt and decrypt messages.
The cipher is based around shifting letters by $N$ letters in the alphabet. The
Romans only had to agree on how many letters they should shift. A modern
example of a secret key encryption scheme is the \textit{Advanced Encryption
Standard} (AES), though the way AES works is out of the scope of this thesis.
Secret-key ciphers have a big issue though, since all parties need to have the
same key we have no good way to exchange them.

When we encrypt messages, there are two different types of ciphers we can use,
stream- and block ciphers. A stream cipher is a type of cipher that encrypts a
bit or in some scenarios a byte at a time. Block ciphers on the other hand take
a block of data and transform into an unreadable block of the same length.


\section{Public key cryptography}
Cryptography was revolutionized in the 70s when the \textit{Diffie and Hellman
key exchange} and RSA was invented. It solved the issues of exchanging keys as
well as providing the means to implement authentication. \textit{Public key
cryptography}, also know as \textit{asymmetric cryptography} is a type of
cryptography that works by having a public- and a private key
that are used for encryption and decryption. As the name implies, the public
key is known to everyone while the private key should remain secret.

When we encrypt something we assume some problem is hard for a computer to
solve. One of the most common methods we currently use is the discrete
logarithm problem.

\begin{definition}
    Let $g$ be a generator for the group $G$ and $\forall x \in \mathbb{N}$. The
    discrete logarithm problem is that given $x = g^m$, find $m$.
\end{definition}

The Diffie and Hellman key exchange utilizes this problem to exchange keys.

\begin{definition}

    The Diffie and Hellman key exchange works as follows. Let $g$ be a generator
    element for the group $G$ of integers modulo $p$. Alice picks a random
    natural number $a$ and sends $g^a$ to Bob. Bob then picks a random number
    $b$ and sends $g^b$ to Alice. Alice then computes $g^{ab}$ and Bob computes
    $g^{ba}$. Consequently Alice and Bob now share a secret key $g^{ab}$
    \citep{FranciscoRodriguez-Henriquez10}.

\end{definition}

Due to the recent developments in quantum computing some of the problems we
considered hard, such as the finding the discrete logarithm, integer
factorization as well as the elliptic curve problem can be broken in polynomial
time \citep{ShorQuantum}. This means we have to quickly move away from the
cryptographic methods we currently use. There are a few cryptographic functions
that have gotten popular that are hard even for quantum computers. An example
of a hard problem for quantum computers is a lattice based problem,
\textit{Ring Learning With Errors} (R-LWE)
\citep{FPGA_Post_Quantum_Primitives}.

\begin{definition}
    A lattice in $\mathbb{R}^n$ is all of the combinations you can generate
    from a given vector.

    \[L = \left\{ \sum_{i = 0}^n a_iv_i \, | \, a_i \in \bZ \right\}\]
\end{definition}

\begin{definition}
    Learning with errors works as follows, let $\chi$ be a discrete Gaussian
    distribution. Alice first picks a public vector $a \in (\bZ / q\bZ)^n$, a
    secret vector $s \in (\bZ / q\bZ)^n$ and an error $\chi \rightarrow e$.
    Alice then computes $b$.

    \[ b = a \cdot s + e \]

    We then send $a$ and $b$ to Bob.
\end{definition}

The R-LWE problem is based around the \textit{Learning With Errors} (LWE)
problem. The LWE problem is considered hard to solve for quantum computers
\citep{Regev05}. The issue that R-LWE tries to solve is speed. LWE is based
around matrix multiplication which is $\mathcal{O}(n^2)$. R-LWE can use the
\textit{Fast Fourier Transform} (FFT) to change the worst case time complexity
to $\mathcal{O}(n\log n)$.

In \citep{FPGA_Post_Quantum_Primitives} we get the following definitions for
key exchange, encryption and decryption.

\begin{definition}[\textbf{Key exchange}]

    R-LWE is built around polynomial arithmetic, the general definition of a
    polynomial is the following.

    \[ g(x) = a_0 + a_1 \cdot x + \ldots + a_{n-1} \cdot x^{n-1} + a_n \cdot x^n \]

    Let the ring $R_q^n = \bZ[x]/(x^n + 1)$ where $x^n + 1$ is an irreducible
    polynomial, $n$ is a power of 2. Let $q \equiv 1\ (\text{mod } 2n)$ be a
    large prime number and $\chi$ a Gaussian distribution
    \citep{FPGA_Post_Quantum_Primitives}.

    Let Alice pick a public vector $a \in R_q^n$, a secret vector $s \in R_q^n$
    and an error $\chi \leftarrow e$. Using FFT to calculate quickly $b$, after
    which $\{a,b\}$ is sent to Bob.

    \[b = a \cdot s + e \]

\end{definition}

\begin{definition}[\textbf{Encryption}]
    Let $t = \lfloor \frac{q}{2} \rfloor, \quad r_0,\ r_1,\ r_2
    \leftarrow \chi$, Bob then converts the message $m$ to a bit string and
    computes $\{c_0, c_1\}$.

    \[
        \begin{cases}
            c_0 = b \cdot r_0 + r2 + tm\\
            c_1 = a \cdot r_0 + r1
        \end{cases}
    \]

\end{definition}

\begin{definition}[\textbf{Decryption}]
    Alice can decrypt the cipher by computing

    \[m = \lceil (c_0 - c_1 \cdot s) / t) \rfloor \]

    Where $\lceil \rfloor$ is rounding to the nearest integer.
\end{definition}

% Remove this section, not really relevant?
\subsection{Hash functions}
\begin{definition}

A \textit{hash function} H is a one-way function that takes an arbitrary length
bit string B, a \textit{message}. Then it creates a unique bit string of fixed
length, H(B) is a hash or digest of B \cite{FranciscoRodriguez-Henriquez10}.

\end{definition}

I.e. hash functions create a hash, a unique string of bytes from a given input.
Hash functions are not perfect, although having a very small chance of two
inputs having the same output it can happen. This is a terrible thing for hash
functions as a malicious user could then fake for example a private key.


