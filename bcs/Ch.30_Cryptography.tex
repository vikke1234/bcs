\chapter{Cryptography\label{crypto}}
In this chapter we will discuss different forms of cryptography and the
mathematics behind it. Cryptography has been used since ancient times to secure
communication. One of the earliest forms of cryptography is the Caesar cipher,
invented by Julius Caesar in ancient Rome. The Caesar cipher is a
\textit{secret-key cipher}\footnote{A symmetric cipher}. A symmetric cipher is
a cipher where users agree on a key that is used to both encrypt and decrypt
messages. The Caesar cipher is based on shifting letters by $N$ letters in the
alphabet, where the encryption/decryption key is $N$. The Romans only had to
agree on how many letters they should shift (the key). A modern example of a
secret key encryption scheme is the \textit{Advanced Encryption Standard}
(AES), though the way AES works is out of the scope of this thesis. Secret-key
ciphers have a practical issue, since all parties need to use the same key, in
this setting we have no obvious way to exchange keys. However, \textit{public
key cryptography} was developed to solve the issue of key exchange.


\section{Public key cryptography}
Cryptography was revolutionized in the 70s when the \textit{Diffie and Hellman
key exchange} and RSA were invented. It solved the issues of exchanging keys.
Public key cryptography, also know as \textit{asymmetric cryptography}
is a type of cryptography that works requiring two keys (in contrast with
symmetric cryptography), a public- and a private key that are used for
encryption and decryption. As the name implies, the public key is known to
everyone while the private key should remain secret. We illustrate this by the
following generic example of public key encryption.

\begin{example}
    Assume first that Alice generated a pair of public and secret keys denoted
    by pk and sk respectively. Alice then publishes the public key. Suppose that
    Bob wants to send an encrypted message to Alice, Bob will use Alice's
    public key pk to encrypt with her secret key and sends it Alice. Finally
    Alice will use sk to decrypt the received message.
\end{example}

Usually asymmetric encryptions are built of some hard mathematical problems.
By proving that the only way to "break" the encryption is to solve some
precise mathematical problem that is proved to be computationally hard.
Examples of such problems include the discrete logarithm problem and the
integer factorization problem.

\begin{definition}[\textbf{Discrete logarithm problem}]

    Let $g$ be a generator for the group $G$ and $\forall x \in \mathbb{N}$,
    given $x = g^m$, find $m$.

\end{definition}

\begin{definition}[\textbf{Integer factorization problem}]

    Given a product of two prime numbers $n$, factorize $n$ into the two prime
    numbers $p$ and $q$.

\end{definition}

Unfortunately, such problems were proven to be possible to break with a
sufficiently large quantum computer in polynomial time \citep{ShorQuantum}. In
the next section we will discuss some examples of post-quantum resistant
cryptography.


\section{Post-quantum cryptography}

Due to the recent developments in quantum computing some of the problems
considered hard, the discrete logarithm and integer factorization problem can
be broken easily. Hence the interest in developing mathematical problems that
are believed to be hard even for quantum computers. Examples of such problems
arise from coding theory, systems of multi variable polynomials and lattice
theory. In this thesis we will mainly focus on lattice based cryptography.


\subsection{Lattice based cryptography}

\begin{definition}
    A lattice in $\mathbb{R}^n$ is all of the combinations you can generate
    from a given basis of independent vectors $B = \{v_1,\ \ldots,\ v_n\}$.

    \[L = \left\{ \sum_{i = 0}^n a_iv_i \, | \, a_i \in \bZ \right\}\]
\end{definition}


We can define the shortest vector in the lattice $L$ to be
$\lambda(L) = \min || y ||, \quad \forall y \in L$ where
$||x|| = \{\sqrt{\sum_{i=0}^n x^2_i}\}, \quad x = (x_1, \ldots, x_n)$.

There exist a few problems using lattices that are believed to be NP-hard for
quantum computers. One of these is the shortest vector problem: let $\gamma \in
\mathbb{R}_+$, find $x \in L$
such that $||x|| \leq \gamma \lambda(L)$

In 2005 Regev showed that \textit{Learning With Errors} (LWE) is a hard
problem, by solving LWE we could solve the shortest vector problem in lattices
\citep{Regev05}.


\begin{definition}[\textbf{Learning With Errors}]
    Let $\chi$ be a discrete Gaussian
    distribution. Alice first picks a public vector $a \in (\bZ / q\bZ)^n$, a
    secret vector $s \in (\bZ / q\bZ)^n$ and an error $\chi \rightarrow e$.
    Alice then computes $b$.

    \[ b = a \cdot s + e \]

    We then send $a$ and $b$ to Bob.
\end{definition}

LWE is a slow problem  slow for a computer to compute, this is where
\textit{Ring Learning With Errors} (R-LWE) comes in. By doing multiplication
over the ring $\bZ^n_q$ where the ring $R_q = \bZ[x] / (x^n + 1)$, we can we can
reduce the complexity from $\mathcal{O}(n^2)$ to $\mathcal{O}(n\log n)$.

In \citep{FPGA_Post_Quantum_Primitives} we get the following definitions for key
generation, encryption and decryption.

\begin{definition}[\textbf{Key exchange}]
    % TODO Remove R-LWE definitions
    R-LWE is built around polynomial arithmetic, the general definition of a
    polynomial is the following.

    \[ g(x) = a_0 + a_1 \cdot x + \ldots + a_{n-1} \cdot x^{n-1} + a_n \cdot x^n \]

    Let the ring $R_q^n = \bZ[x]/(x^n + 1)$ where $x^n + 1$ is an irreducible
    polynomial, $n$ is a power of 2. Let $q \equiv 1\ (\text{mod } 2n)$ be a
    large prime number and $\chi$ a Gaussian distribution
    \citep{FPGA_Post_Quantum_Primitives}.

    Let Alice pick a public vector $a \in R_q^n$, a secret vector $s \in R_q^n$
    and an error $\chi \leftarrow e$. Using FFT to calculate quickly $b$, after
    which $\{a,b\}$ is sent to Bob.

    \[b = a \cdot s + e \]

\end{definition}

\begin{definition}[\textbf{Encryption}]
    Let $t = \lfloor \frac{q}{2} \rfloor, \quad r_0,\ r_1,\ r_2
    \leftarrow \chi$, Bob then converts the message $m$ to a bit string and
    computes $\{c_0, c_1\}$.

    \[
        \begin{cases}
            c_0 = b \cdot r_0 + r2 + tm\\
            c_1 = a \cdot r_0 + r1
        \end{cases}
    \]

\end{definition}

\begin{definition}[\textbf{Decryption}]
    Alice can decrypt the cipher by computing

    \[m = \lceil (c_0 - c_1 \cdot s) / t) \rfloor \]

    Where $\lceil \rfloor$ is rounding to the nearest integer.
\end{definition}

